{"version":3,"sources":["balance.js"],"names":["balance","headings","canvas","document","createElement","ctx","getContext","segmenter","TinySegmenter","DEBUG","width","height","body","appendChild","it","i","text","textContent","style","window","getComputedStyle","parseFloat","getPropertyValue","lineHeight","console","log","lineCount","Math","round","font","join","segments","segment","j","len","length","test","splice","map","seg","measureText","result","minWidth","current","getClientRects","invalid","unshift","push","k","w","reduce","r","t","fillText","s","shift","pop","split","reverse"],"mappings":"AAKA,QAASA,SAASC,GAkBjB,GAAIC,GAASC,SAASC,cAAc,UAChCC,EAAMH,EAAOI,WAAW,MAExBC,EAAY,GAAIC,cAChBR,SAAQS,MAAQ,IACnBP,EAAOQ,MAAQ,IACfR,EAAOS,OAAS,IAChBR,SAASS,KAAKC,YAAYX,GAG3B,KAAK,GAAWY,GAAPC,EAAI,EAAQD,EAAKb,EAASc,GAAKA,IAAK,CAC5C,GAAIC,GAAOF,EAAGG,YACVC,EAAQC,OAAOC,iBAAiBN,EAAI,MACpCH,EAAaU,WAAWH,EAAMI,iBAAiB,WAC/CZ,EAAaW,WAAWH,EAAMI,iBAAiB,UAC/CC,EAAaF,WAAWH,EAAMI,iBAAiB,eACnD,KAAKZ,IAAUC,EAEd,YADIX,QAAQS,OAAOe,QAAQC,IAAI,OAAQ,8BAGxC,KAAKF,EAEJ,YADIvB,QAAQS,OAAOe,QAAQC,IAAI,OAAQ,uBAIxC,IAAIC,GAAYC,KAAKC,MAAMjB,EAASY,EAEpC,IAAkB,IAAdG,EAAJ,CAMArB,EAAIwB,MACHX,EAAMI,iBAAiB,cACvBJ,EAAMI,iBAAiB,gBACvBJ,EAAMI,iBAAiB,eACvBJ,EAAMI,iBAAiB,gBACvBJ,EAAMI,iBAAiB,aACvBJ,EAAMI,iBAAiB,gBACtBQ,KAAK,KACH9B,QAAQS,OAAOe,QAAQC,IAAIpB,EAAIwB,KAMnC,KAAK,GAHDE,GAAWxB,EAAUyB,QAAQhB,GAGxBiB,EAAI,EAAGC,EAAMH,EAASI,OAAS,EAAGF,EAAIC,EAAKD,IAElD,eAAeG,KAAKL,EAASE,KAC7B,eAAeG,KAAKL,EAASE,EAAE,MAE/BF,EAASE,IAAMF,EAASE,EAAE,GAC1BF,EAASM,OAAOJ,EAAE,EAAG,GACrBC,IAEAD,IAIFF,GAAWA,EACVO,IAAI,SAAUC,GACb,OACCvB,KAAMuB,EACN7B,MAAOL,EAAImC,YAAYD,GAAK7B,SAI3BV,QAAQS,OAAOe,QAAQC,IAAIM,EAASO,IAAI,SAAUvB,GAAK,MAAOA,GAAEC,OAAQc,KAAK,OAEjF,IAAIW,QACAC,EAAWrC,EAAImC,YAAYxB,GAAMN,MAAQgB,EACzCiB,EAAU,CACV3C,SAAQS,OAAOe,QAAQC,IAC1B,SAAUd,EACV,QAASD,EACT,YAAagB,EACb,aAAcH,EACd,WAAYmB,EACZ1B,EAAMF,EAAG8B,iBAOV,KAAK,GADDC,IAAU,EACLZ,EAAI,EAAGC,EAAMH,EAASI,OAAQF,EAAIC,EAAKD,IAAK,CACpD,GAAIM,GAAMR,EAASE,EACnB,IAAIU,EAAUJ,EAAI7B,MAAQgC,EACzB,GAAID,EAAON,OAAST,EACnBe,EAAOK,SAASP,IAChBI,EAAUJ,EAAI7B,UACR,CAEN+B,EAAO,GAAGM,KAAKR,EACf,KAAK,GAAIS,GAAI,EAAGA,EAAIP,EAAON,OAAQa,IAAK,CACvC,GAAIC,GAAIR,EAAOO,GAAGE,OAAO,SAAUC,EAAGpC,GAAK,MAAOoC,GAAIpC,EAAEL,OAAU,EAClE,IAAIV,QAAQS,MAAO,CAClB,GAAI2C,GAAIX,EAAOO,GAAGE,OAAO,SAAUC,EAAGpC,GAAK,MAAOoC,GAAIpC,EAAEC,MAAS,GACjEQ,SAAQC,IAAI,OAAQuB,EAAGC,EAAG,IAAKvC,EAAO0C,EAAG/C,EAAImC,YAAYY,IACrDpD,QAAQS,MAAQ,GACT,IAANuC,GAAS3C,EAAIgD,SAASD,EAAG,GAAI,KAGnC,GAAIH,EAAIvC,EAEP,KAGA,IAAIsC,IAAMP,EAAON,OAAS,EAOnB,CAGNU,GAAU,CACV,OATA,KAAOI,EAAIvC,GAAO,CACjB,GAAI4C,GAAIb,EAAOO,GAAGO,OAClBN,IAAKK,EAAE5C,MACP+B,EAAOO,EAAI,GAAGD,KAAKO,IAUvBX,EAAUF,EAAO,GAAGS,OAAO,SAAUC,EAAGpC,GAAK,MAAOoC,GAAIpC,EAAEL,OAAU,OAGrE+B,GAAO,GAAGM,KAAKR,GACfI,GAAWJ,EAAI7B,MAIjB,GAAKmC,EASE,CACN,GAAIJ,GAASV,EAASO,IAAI,SAAUgB,GACnC,MAAOA,GAAEtC,MAENhB,SAAQS,OAAOe,QAAQC,IAAI,mBAC/BgB,EAAOM,KAAKN,EAAOe,MAAMC,MAAM,IAAI3B,KAAK,WACxChB,EAAGG,YAAcwB,EAAOX,KAAK,QAfhB,CACbW,EAAOiB,SACP,IAAIjB,GAASA,EAAOH,IAAI,SAAUvB,GACjC,MAAOA,GAAEuB,IAAI,SAAUgB,GACtB,MAAOA,GAAEtC,OACPc,KAAK,KAEL9B,SAAQS,OAAOe,QAAQC,IAAIgB,EAAOX,KAAK,QAC3ChB,EAAGG,YAAcwB,EAAOX,KAAK","file":"../../../../../../../tmp/d20170214-20678-pxgpil/balance.js20170214-20678-7t0fp5","sourcesContent":["/**\n * \n * 引数は処理対象のノードリスト。ただし処理が行われると要素内容が置き換わるので、テキストノードのみを含むブロック要素を渡すこと\n *\n */\nfunction balance (headings) {\n\t/*\n\tfunction measureText (parent, text) {\n\t\tvar span = document.createElement('span');\n\t\tspan.textContent = text;\n\t\tspan.style.padding = \"0\";\n\t\tspan.style.margin = \"0\";\n\t\tspan.style.border = \"none\";\n\t\tspan.style.whiteSpace = 'nowrap';\n\t\tparent.appendChild(span);\n\t\tvar width = span.offsetWidth;\n\t\tparent.removeChild(span);\n\t\treturn {\n\t\t\twidth: width\n\t\t};\n\t}\n\t*/\n\n\tvar canvas = document.createElement('canvas');\n\tvar ctx = canvas.getContext('2d');\n\t// 区切りをカスタマイズした TinySegmenter を使うこと\n\tvar segmenter = new TinySegmenter();\n\tif (balance.DEBUG > 1) {\n\t\tcanvas.width = 1000;\n\t\tcanvas.height = 500;\n\t\tdocument.body.appendChild(canvas);\n\t}\n\n\tfor (var i = 0, it; (it = headings[i]); i++) {\n\t\tvar text = it.textContent;\n\t\tvar style = window.getComputedStyle(it, null);\n\t\tvar height     = parseFloat(style.getPropertyValue('height'));\n\t\tvar width      = parseFloat(style.getPropertyValue('width'));\n\t\tvar lineHeight = parseFloat(style.getPropertyValue('line-height'));\n\t\tif (!width || !height) {\n\t\t\tif (balance.DEBUG) console.log('warn', 'node may be inline element');\n\t\t\treturn;\n\t\t}\n\t\tif (!lineHeight) { // line-height: 'normal', 'inehrit' ...\n\t\t\tif (balance.DEBUG) console.log('warn', 'invalid line-height');\n\t\t\treturn;\n\t\t}\n\t\t// inline 要素なら getClientRects().length で行数がえられるが、ブロック要素だとうまい方法がない?\n\t\tvar lineCount = Math.round(height / lineHeight);\n\n\t\tif (lineCount === 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 該当フォントがロード済みである必要あり\n\t\t// Firefox は font プロパティが空になる。\n\t\tctx.font = [\n\t\t\tstyle.getPropertyValue('font-style'),\n\t\t\tstyle.getPropertyValue('font-variant'),\n\t\t\tstyle.getPropertyValue('font-weight'),\n\t\t\tstyle.getPropertyValue('font-stretch'),\n\t\t\tstyle.getPropertyValue('font-size'),\n\t\t\tstyle.getPropertyValue('font-family')\n\t\t].join(' ');\n\t\tif (balance.DEBUG) console.log(ctx.font);\n\n\t\t// 分割\n\t\tvar segments = segmenter.segment(text);\n\n\t\t// 不適切な分割の補正 (スペースなしの英+数の連続は連結するなど)\n\t\tfor (var j = 0, len = segments.length - 1; j < len; j++) {\n\t\t\tif (\n\t\t\t\t/[a-z0-9.-]$/i.test(segments[j]) && \n\t\t\t\t/^[a-z0-9.-]/i.test(segments[j+1])\n\t\t\t) {\n\t\t\t\tsegments[j] += segments[j+1];\n\t\t\t\tsegments.splice(j+1, 1);\n\t\t\t\tlen--;\n\t\t\t\t// さらに連続するケースもあるので再度処理する\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\n\t\tsegments = segments.\n\t\t\tmap(function (seg) {\n\t\t\t\treturn {\n\t\t\t\t\ttext: seg,\n\t\t\t\t\twidth: ctx.measureText(seg).width\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (balance.DEBUG) console.log(segments.map(function (i) { return i.text }).join('\" \"'));\n\n\t\tvar result = [[]];\n\t\tvar minWidth = ctx.measureText(text).width / lineCount;\n\t\tvar current = 0;\n\t\tif (balance.DEBUG) console.log(\n\t\t\t'height', height,\n\t\t\t'width', width,\n\t\t\t'lineCount', lineCount,\n\t\t\t'lineHeight', lineHeight, \n\t\t\t'minWidth', minWidth,\n\t\t\ttext, it.getClientRects()\n\t\t);\n\t\t/*\n\t\t * 一行が minWidth 未満なら無条件に行に追加\n\t\t * 行数が一定を超えないように一行が width 以内になるように調整\n\t\t */\n\t\tvar invalid = false;\n\t\tfor (var j = 0, len = segments.length; j < len; j++) {\n\t\t\tvar seg = segments[j];\n\t\t\tif (current + seg.width > minWidth) {\n\t\t\t\tif (result.length < lineCount) {\n\t\t\t\t\tresult.unshift([seg]);\n\t\t\t\t\tcurrent = seg.width;\n\t\t\t\t} else {\n\t\t\t\t\t// 最低行幅をオーバーするがとりあえず追加する\n\t\t\t\t\tresult[0].push(seg);\n\t\t\t\t\tfor (var k = 0; k < result.length; k++) {\n\t\t\t\t\t\tvar w = result[k].reduce(function (r, i) { return r + i.width; }, 0);\n\t\t\t\t\t\tif (balance.DEBUG) {\n\t\t\t\t\t\t\tvar t = result[k].reduce(function (r, i) { return r + i.text; }, '');\n\t\t\t\t\t\t\tconsole.log('over', k, w, '<', width, t, ctx.measureText(t));\n\t\t\t\t\t\t\tif (balance.DEBUG > 1) {\n\t\t\t\t\t\t\t\tif (k === 1) ctx.fillText(t, 50, 100);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w < width) {\n\t\t\t\t\t\t\t// 最大行幅以内ならなにもしない\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// 最大行幅も超えてしまう場合、行送りをする\n\t\t\t\t\t\t\tif (k !== result.length - 1) {\n\t\t\t\t\t\t\t\t// 最後の行が width 未満になるまで前の行に送る\n\t\t\t\t\t\t\t\twhile (w > width) {\n\t\t\t\t\t\t\t\t\tvar s = result[k].shift()\n\t\t\t\t\t\t\t\t\tw -= s.width;\n\t\t\t\t\t\t\t\t\tresult[k + 1].push(s);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// 送りを繰替えした結果 1行目の長さが width を超えてしまった\n\t\t\t\t\t\t\t\t// つまりこれは分割不可を意味する\n\t\t\t\t\t\t\t\tinvalid = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcurrent = result[0].reduce(function (r, i) { return r + i.width; }, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[0].push(seg);\n\t\t\t\tcurrent += seg.width;\n\t\t\t}\n\t\t}\n\n\t\tif (!invalid) {\n\t\t\tresult.reverse();\n\t\t\tvar result = result.map(function (i) {\n\t\t\t\treturn i.map(function (s) {\n\t\t\t\t\treturn s.text;\n\t\t\t\t}).join('')\n\t\t\t});\n\t\t\tif (balance.DEBUG) console.log(result.join(' | '));\n\t\t\tit.textContent = result.join('\\n');\n\t\t} else {\n\t\t\tvar result = segments.map(function (s) {\n\t\t\t\treturn s.text;\n\t\t\t});\n\t\t\tif (balance.DEBUG) console.log('failed to break');\n\t\t\tresult.push(result.pop().split('').join(\"\\uFEFF\"));\n\t\t\tit.textContent = result.join('');\n\t\t}\n\t}\n}\n\n"]}